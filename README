WebInk is a minimal framework for ruby assisting in website
development. It uses fast-cgi to dispatch and works under linux.

Here is a small guide to installing it.





== Requirements

A linux server with ruby, rubygems, (lighttpd or apache or
nginx), (mysql or sqlite3), fast-cgi and the installed gems
for fcgi, (mysql or sqlite3) and webink.





== Webserver




lighttpd

The http://localhost should already work, so let's move on
to the configuration. Inside your /etc/lighttpd folder you
find a config file "lighttpd.conf". Here you enter the details
the server should respect. Probably inside a

  $HTTP["host"] =~ "something" { 
    ...
  }

would be an appropriate place to insert this piece of code:

  server.document-root = "/var/www/"

  url.rewrite-once = (
    "^/errors(.*)$" => "/errors$1",
    "^/status-([0-9]*).html$" => "/status-$1.html",
    "^(.*)$" => "/rfcgi?controller=$1",
  ),

  fastcgi.server = (
    "/rfcgi" => (
      (
        "bin-path" => "/usr/bin/rfcgi",
        "docroot" => "/var/www/",
        "socket" => "/tmp/mrb.socket",
        "check-local" => "disable",
        "max-procs" => 1,
        "bin-environment" => (
          "INK_PRODUCTION" => "false",
          "INK_ERRORS" => "false",
        ),
      )
    ),
  ),

Adjust the document-root to the folder that your project will be
located in. Rewrite rules are important, as they allow you to send
all request URIs to the webink dispatcher, except, for instance,
a files subfolder to serve the files directly.

The fastcgi server takes all links that start with /rfgci, that is
what we have rewritten all our requests to honor. Of course a
dispatcher needs to be an executable. It comes with the gem, and
is put into your bin folder, on debian lenny that is /usr/bin/rfcgi
and should work for you. Specifying the doc-root is helpful for the
dispatcher, so is the socket. Disable check-local so the fastcgi
immediately processes the incoming request. Adding information to
the bin-environment will help the dispatcher to serve requests either
in production mode, displaying an error-trace, or using an internal
or external error plan. In case you want to use an internal error plan,
provide the following two files: /status-404.html and /status-500.html.
The dispatcher will use a redirect to there. Using the external scheme
will require a configuration of lighttpd's error prefix. Remember to
insert appropriate URL writes.





apache

The http://localhost should work fine. Before we can configure the apache,
the modules need to be enabled. Apache provides a quick shell command for
this.

  a2enmod fastcgi
  a2enmod actions
  a2enmod headers
  a2enmod include

Now find the default config in /etc/apache2/site-available/. Alternatively
you can always create a new config in there, and enable it with the
corresponding shell command. For this example, we simply overwrite the
default config with this.

  <VirtualHost *:80>
    ServerName localhost
    ServerAlias localhost
    ServerAdmin webmaster@example1.com
    DocumentRoot /var/www

    <IfModule mod_fcgid.c>
    <IfModule mod_rewrite.c>
      <Directory /var/www>
        RewriteEngine On
        AllowOverride All

        SetEnv INK_PRODUCTION false
        SetEnv INK_ERRORS true

        RewriteCond %{REQUEST_URI} !^/rfcgi\.fcgi
        RewriteRule ^(errors.*)$ $1 [L]
        RewriteRule ^(status.*)$ $1 [L]
        RewriteRule ^(.*)$ rfcgi.fcgi?controller=/$1 [L]

        Order allow,deny
        Allow from all

        AddHandler fcgid-script .fcgi
        Options +ExecCGI
      </Directory>
    </IfModule>
    </IfModule>
    ServerSignature Off

  </VirtualHost>

It's way more complex than lighttpd, but the basics remain the same.
This virtualhost listens to port 80 on the localhost. Set the document
root to your liking and adjust the Directory tag with it. We need a
rewrite condition to prevent any rewrites on URIs starting with rfcgi.fcgi,
yet rewrite the rest in a similar manner as we did with the lighttpd
config. Also similar are the environmental settings for production and
errors. It is recommended to set INK_ERRORS to true and use internal
error handling with /status-404.html and /status-500.html. Adding a
handler for fcgid listening to the extension .fcgi completes our config,
together with being able to execute cgi scripts.

The config requires an fcgi script to execute, so we copy the one webink brings.

  cp /usr/bin/rfcgi /var/www/rfcgi.fcgi

This should work in most cases, but if it does NOT work for you, copy
the one from

  /usr/lib/ruby/gems/1.9.1/gems/webink-1.2.3/bin/rfcgi

and add these lines to the top:

#!/usr/bin/ruby
require "rubygems"

It is now allowed to be executed and find the gem-paths required to run
it.





nginx

nginx has a tiny problem, it has no included spawn-fastcgi. Therefore we
just grab the one from lighttpd. (you can also compile lighttpd and copy
spawn-fcgi after make)

When lighttpd complains that port 80 is already in use, ignore it. Basically
you can remove lighttpd after you have saved /usr/bin/spawn-fcgi or you
can disable lighttpd by removing it from init.d. nginx on the other hand
should respond to http://localhost.

First off we need a small program, that spawns the fcgi listener to handle
communication between the dispatcher and nginx.

  touch /usr/bin/ruby-fastcgi
  chmod 755 /usr/bin/ruby-fastcgi
  nano /usr/bin/ruby-fastcgi


  #!/bin/sh
  /usr/bin/spawn-fcgi -a 127.0.0.1 -p 9000 -u www-data -f /usr/bin/rfcgi

Enter the last two lines of the code above into ruby-fastcgi. It will spawn
the executable from webink /usr/bin/rfcgi as a dispatcher. Make sure that
the executable is where it's supposed to be. Now we want to run this
executable automatically whenever the server starts.

  touch /etc/init.d/init-fastcgi
  chmod 755 /etc/init.d/init-fastcgi
  update-rc.d init-fastcgi defaults
  nano /etc/init.d/init-fastcgi

Create this small init script inside the init.d and paste the following
code into it.

  #!/bin/bash
  RUBY_SCRIPT=/usr/bin/ruby-fastcgi
  RETVAL=0
  case "$1" in
      start)
        $RUBY_SCRIPT
        RETVAL=$?
    ;;
      stop)
        killall -u www-data -r rfcgi
        RETVAL=$?
    ;;
      restart)
        killall -u www-data -r rfcgi
        $RUBY_SCRIPT
        RETVAL=$?
    ;;
      *)
        echo "Usage: init-fastcgi {start|stop|restart}"
        exit 1
    ;;
  esac      
  exit $RETVAL

You can start, stop and restart the rfcgi process now, as long as the path
to init-fastcgi is correct. Adjust the killall lines, if you do not intend
to start the dispatcher with this user. Remember to correct this inside
ruby-fastcgi too.

The last step to run the framework is the server config found in
/etc/nginx/sites-available/. Edit the default config to look like this:

  server {
    listen   80;
    server_name  _;

    access_log  /var/log/nginx/localhost.access.log;
    #error_page  404  /404.html;

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
      root   /var/www;
    }


    location ~ ^/ {
      root /var/www;
      fastcgi_pass   127.0.0.1:9000;
      fastcgi_param SCRIPT_FILENAME $document_root/rfgci;
      include fastcgi_params;
      fastcgi_param QUERY_STRING controller=$uri&$args;
    }
  }

The server listens to port 80 again and has a handle for some server errors.
The important part is found under location ~ ^/, which triggers whenever
someone requests an URI. We remember that the fastcgi dispatcher was spawned
on port 9000, and that is where we pass the data to. The script name of the
request (and may it be imaginary) is /var/www/rfcgi, derived from the document
root. This script name does not exist, nor does it need to, similar as in the
lighttpd config. To prevent data loss, we add $args to the query string, which
attaches the incoming query. Unfortunately nginx does not allow custom
fastcgi_params to be set. This prevents us from setting production and error
message environmentals for the dispatcher, so you will have to dig into the
rfcgi executable yourself.





== Installation

The project folder can be located anywhere on the system, but most admins
seem to like /var/www as its root. Some web hosters even encourage you to
use your home folder. Where ever this may be, you need to provide a certain
structure, so the dispatcher can find its resources. Assume the project
foldername "blog".

  config.rb   --this configures the project
  init.rb     --loads the project, processes incoming requests and passes
              --them on to the controllers
  routes.rb   --handles all the routing
  controllers --this folder contains all controller files
  models      --this folder contains all models
  views       --this folder contains all views

The configuration of the project allows some global parameters, as well as
the location of the database. Certainly you can set your own parameters
additionally to those required for the project. This is what it looks like:

  config = {
    "escape_post_data" => false,

    "db_server" => "/path/to/database.sqlite",
    "db_type" => "sqlite3",

    "db_type" => "mysql",
    "db_user" => "username",
    "db_pass" => "password",
    "db_database" => "database name",
    "db_server" => "localhost",
  }

This config is divided into three blocks. First off the possible global
settings. Then a config for an sqlite3 project, and last a config for
mysql. All of the settings are pretty self-explaining.

Whenever the dispatcher loads the project, it consults the init.rb to pass
on the data. This comes with a disadvantage and an advantage. Unfortunately
every project requires this init.rb, leaving much room for error when
configurating it, which certainly is a bad thing for some developers out
there. On the other hand, it allows you to easily get rid of all the includes,
that you do not need, or add your own, and maybe extend so the includes will
only be considered when certain modules and controllers are called. Here
is what it should look like, comments are excluded.

  require 'erb'
  require "#{params[:config]["db_type"]}"
  require "webink"

  models = Dir.new "./models"
  models.each do |model|
    load "#{models.path}/#{model}" if model =~ /\.rb$/
  end
  load "./controllers/#{params[:controller]}.rb"

  Ink::Database.create params[:config]

  controller = (Ink::Controller.verify params[:controller]).new params
  response = (controller.verify params[:module]).call

  Ink::Database.database.close

The first block loads all includes. Webink relies on erb-Templates and,
of course, on the database, that was configured inside config.rb. The
second block dynamically loads all models in the corresponding folders
and the requested controller. Then we load the database, instanciate
the controller, call the module and close the database again. Easy, right?

The most important piece for getting the framework to do what you have
in mind are the routes. You need to know some basic regular expressions,
but theoretically can support any regex that ruby has to offer. Here
is a small example for the routes.rb.

  root = "/rblog"

  # route priority:
  # /:controller/:module/:page [-- :page can only consist of numbers
  # /:controller/:module       [--
  # /:controller               [-- :module is set to index per default
  # /                          [-- :controller defaults to blog, :module to index
  routes = [
    [ /^\/([^\/]+)\/([^\/]+)(\/([0-9]+)\/?)$/, {:controller => "$1", :module => "$2", :page => "$4"} ],
    [ /^\/([^\/]+)\/([^\/]+)\/?$/, {:controller => "$1", :module => "$2"} ],
    [ /^\/([^\/]+)\/?$/, {:controller => "$1", :module => "index"} ],
    [ /^\/?$/, {:controller => "blog", :module => "index"} ],
  ]

  Ink::Beauty.routing root, routes, params

Again, we have three blocks. Every project is somewhere relative on the
server, from a HTTP perspective that is, which is represented by the root
variable. In our case you can reach the project via
http://my.server.com/rblog, and from here the routes will do the rest.
The second block configures the routes themselves. An array of arrays,
that are priorized from top to bottom, meaning the first hit with the
regular expression will determine the route taken. The regex is interpreted
as always, and the results can be assigned to symbols, provided in the hash.
At last the actual route-interpreter is called, and that concludes the
routes.rb.

For more information on the folders, have a look at the sample project.

